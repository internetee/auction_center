#!/bin/bash
set -e

# Remove a potentially pre-existing server.pid for Rails
rm -f /opt/webapps/app/tmp/pids/server.pid

# Ensure proper environment variables are set for Rails in production mode
if [ "$RAILS_ENV" == "production" ] || [ "$RAILS_ENV" == "staging" ]; then
  # Check if the master key is provided
  if [ -n "$RAILS_MASTER_KEY" ]; then
    echo "RAILS_MASTER_KEY environment variable is set. Using Rails credentials system."
  # If no master key, check for secret key base
  elif [ -n "$SECRET_KEY_BASE" ]; then
    echo "SECRET_KEY_BASE environment variable is set. Using direct secret key configuration."
  else
    echo "WARNING: Neither RAILS_MASTER_KEY nor SECRET_KEY_BASE environment variables are set."
    echo "Generating a temporary SECRET_KEY_BASE. This is okay for testing but NOT recommended for real production use."
    export SECRET_KEY_BASE=$(openssl rand -hex 64)
  fi
fi

# Check for database connection settings - using the APP_DBHOST variable from database.yml
if [[ -n "$DATABASE_URL" || -n "$APP_DBHOST" ]]; then
  # Get database host from DATABASE_URL or APP_DBHOST
  if [ -n "$DATABASE_URL" ]; then
    # Extract host from DATABASE_URL
    DB_HOST=$(echo $DATABASE_URL | awk -F[@//] '{print $4}' | cut -d':' -f1)
  else
    DB_HOST=$APP_DBHOST
  fi
  
  # Get database user from APP_DBUSER or default to postgres
  DB_USER=${APP_DBUSER:-postgres}
  
  # Wait for PostgreSQL to be available
  echo "Checking PostgreSQL connection to $DB_HOST..."
  until pg_isready -h $DB_HOST -p ${APP_DBPORT:-5432} -U $DB_USER 2>/dev/null; do
    echo "Waiting for PostgreSQL to be available..."
    sleep 2
  done
  echo "PostgreSQL is available."
  
  # Set up database if needed (useful for initial deployments)
  if [ "${DB_SETUP:-false}" = "true" ]; then
    echo "Setting up database..."
    bundle exec rails db:setup
  fi
  
  # Run database migrations if needed
  if [ "${AUTO_MIGRATE:-false}" = "true" ]; then
    echo "Running database migrations..."
    bundle exec rails db:migrate
  fi
else
  echo "Database connection settings not found. Skipping database checks."
fi

# Check for Redis connection if Redis is used
if [ -n "$REDIS_URL" ]; then
  echo "Redis URL is set to $REDIS_URL"
  # Attempting Redis connection
  if command -v redis-cli &> /dev/null; then
    echo "Checking Redis connection..."
    REDIS_HOST=$(echo $REDIS_URL | sed -E 's/^redis:\/\/(.*):([0-9]+)\/([0-9]+)$/\1/')
    REDIS_PORT=$(echo $REDIS_URL | sed -E 's/^redis:\/\/(.*):([0-9]+)\/([0-9]+)$/\2/')
    
    if [ -n "$REDIS_HOST" ] && [ -n "$REDIS_PORT" ]; then
      until redis-cli -h $REDIS_HOST -p $REDIS_PORT ping > /dev/null 2>&1; do
        echo "Waiting for Redis to become available..."
        sleep 2
      done
      echo "Redis is available."
    else
      echo "Could not parse Redis host and port from REDIS_URL. Skipping Redis connection check."
    fi
  else
    echo "redis-cli not available. Skipping Redis connection check."
  fi
fi

# Prepare assets if needed (precompilation should have been done during build)
if [ "${PRECOMPILE_ASSETS:-false}" = "true" ] && { [ ! -d /opt/webapps/app/public/assets ] || [ -z "$(ls -A /opt/webapps/app/public/assets)" ]; }; then
  echo "Precompiling assets..."
  bundle exec rails assets:precompile
fi

# Create readiness indicator for Kubernetes probes
mkdir -p /opt/webapps/app/tmp/k8s
touch /opt/webapps/app/tmp/k8s/ready

echo "Auction Center application is ready to serve requests!"

# Execute the container's main process (what's set as CMD in the Dockerfile)
exec "$@"